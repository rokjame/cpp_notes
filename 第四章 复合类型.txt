第四章 复合类型
1、数组可以储存多个同类型的值；结构可以存储多个不同类型的值；指针则是一种将数据所处位置地告诉计算机的变量。
2、数组：
（1）、数组元素个数不能是变量，可以是整型常数或const值，也可以是常量表达式。（可通过new运算符避开这种限制）
（2）、没有通用的数组类型，但有很多特定的数组类型。
（3）、编译器不会检查使用的下标是否有效。
（4）、只有在定义数组时才能初始化值，此后就不能了，但可以通过下标分别给数组中的元素赋值，也不能将一个数组赋给另一个数组。
	int card[4] = {1,2,3,4};
（5）、不可使用=将一个数组的元素赋给另一个数组，不允许缩窄转换。
3、字符串：
（1）、C-字符串以空字符结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。
（2）、“S“实际上是由S和\0组成的字符串，注意，”S“实际上表示的是字符串所在的内存地址。而‘S‘只是83的一种ASCII码写法。
因此： char shirt_size = “S”；语句是试图将一个内存地址赋给shirt_size。
（3）、如果将某个char数组的某个元素设置为 ’\0’ ，则该数组将在这个元素结束。
（4）、cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将字符串放到数组中，并自动在结尾添加空白字符。
(5)、getline()将丢弃换行符，get()将保留换行符。

4、结构：
（1）、结构是用户定义的类型，而结构声明定义可这种类型的数据类型。
（2）、C++不提倡使用外部变量，但提倡使用外部结构声明。
（3）、可以使用赋值运算符“=“将结构赋给另一个同类型的结构，即使成员是数组，这样结构中的每个成员都将被设置为另一个结构中相应的值。这种赋值被成为”成员赋值“。
（4）、可通过成员运算符“.”访问结构体成员。
（5）不允许缩窄转换。
5、共用体：
（1）、共用体是一种数据格式，它能够存储不同的类型数据，但同时只能储存其中一种类型。
（2）、由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。
（3）、共用体主要用于节省内存空间，也常用于操作系统数据结构或硬件数据结构。
6、枚举：
   （1）、enum工具提供一种创建符号常量的方式，还允许定义新类型。
   （2）、在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。
   （3）、对于枚举，只定义了赋值运算符。
   （4）、枚举量作为符号常量，对应整数值 0-n。因此输出这些值会是整数。
 
  （5）、枚举量是整型，因此可被提升为int类型，但int类型不能自动转换为枚举类型。
  （6）、每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
7、指针：
  （1）、指针是一个变量，其储存的是值的地址，而不是值本身。
  （2）、运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。运行阶段决策提供了灵活性，可以根据当时的情况进行调整。
  （3）、可以在声明语句中初始化指针，在这种情况下，被初始化的是指针，而不是指向它的值。
   Int higgens = 5；
   Int * pt = &higgens;
   上面的语句将pt（而不是*pt）的值设置为&higggens;
  （4）、在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。因此一定要在对指针应用解除引用运算符*之前，将指针初始化为一个确定的、适当的地址。
  （5）、变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值，在这种情况下，只能通过指针来访问内存。
（6）、地址和整数是截然不同的数据类型，因此不能简单地将整数赋给指针。若需要将数字值当作地址来使用，应通过强制类型转换将数字转换为适当的地址类型。
Int * pt;
Pt = (int *)0xB80000000;
（7）、只能用delete来释放new分配的内存，delete不能用于释放变量声明的内存。对空指针使用delete是安全的。
8、动态数组：
  （1）、静态联编：如果通过声明来创建数组，则在程序被编译时将为它分配内存空间，不管程序最终是否使用数组，数组都在那里，并占用内存。动态联编：若使用new，如果在运行阶段需要数组，则创建它，如果不需要，则不创建，还可以在程序运行时选择数组的长度。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。
 
（2）、使用new创建动态数组时，指针指向数组第一个元素的地址。将指针名+1后指针将指向第二个元素的地址。将指针变量加1后，其增加的值等于指向的类型占用的字节数。
 
（3）、数组名其实就是数组第一个元素的地址，因此可以直接将数组名赋给指针。    
Int *pw = wages;  //wages是一个数组
Int *ps = &wages[0]; //两个语句等效
 （4）、面对char类型的数组，如char name[10]，cout << name 会输出该地址处的字符。
       其余类型的数组会输出地址。
 
（5）、使用new[]运算符创建数组时，将采用动态联编，即在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用delete释放其占用的内存。
（6）自动存储：在函数内部定义的常规变量使用自动存储空间，被 称为自动变量，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。通常存储在栈中，后进先出。
静态存储：①在函数外面定义它；②在声明变量时使用关键字static。静态存储时整个程序执行期间都存在的存储方式。自动存储与静态存储的关键在于：这些方法严格地限制了变量的寿命。
动态存储：new和delete管理了一个内存池，被称为自由存储空间（free store）或者堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。New和delete能够在一个函数中分配内存，而在另一个函数中释放它。
（7）内存泄漏：若使用了new而没有使用delete，即使包含指针的内存由于作用域规则和对象生命周期的原因被释放，在自由存储空间上动态分配的变量或结构也将继续存在。但是，将会无法访问堆中的结构，因为指向这些内存的指针无效。被泄露的内存在程序的整个生命周期中都不可使用。

 
